---
title: "MATH2349 Semester 2, 2018"
author: "Verity Miles(s3644459), Sam Holt (s3381728), Meg Cuddihy (s3608125)"
date: "17 October 2018"
output:
  html_notebook: default
  html_document:
    df_print: paged
subtitle: Assignment 3
---

## Required packages 

```{r echo=TRUE, warning=FALSE}
library(readr)
library(readxl)
library(dplyr)
library(tidyr)
library(knitr)
library(mlr)
```


## Executive Summary 


In your own words, provide a brief summary of the preprocessing. Explain the steps that you have taken to preprocess your data. Write this section last after you have performed all data preprocessing. (Word count Max: 300 words)


## Data 

We have used two different datasets.  

####Data set 1: Education Levels

The first data set that we used comes from the 2016 Australian Census made available by the Australian Bureau of Statistics (ABS). We used a public TableBuilder account to extract education level for each SA1 within Victoria. [Click here for information on TableBuilder](https://auth.censusdata.abs.gov.au/webapi/jsf/login.xhtml). SA1s are the smallest geographic unit that the majority of census data is available at.   They generally have a population of between 200 and 800 people. [Click here for more information](http://www.abs.gov.au/ausstats/abs@.nsf/Lookup/by%20Subject/1270.0.55.001~July%202016~Main%20Features~Statistical%20Area%20Level%201%20(SA1)~10013).  

The columns in this data set are:  
<ul>
<li> SA1 7 digit code  
<li> Postgraduate Degree Level  
<ul><li> Doctoral Degree Level </ul> 
<ul><li> Masters Degree Level  </ul>
<li> Graduate Diploma and Graduate Certificate Level  
<li> Bachelor Degree Level  
<li> Advanced Diploma and Diploma Level  
<li> Certificate III & IV Level  
<li> Secondary Education Years 10 and above  
<li> Certificate I &II Level  
<li> Secondary Education Years 9 and below  
<li> Supplementary Codes  
<li> Not stated  
<li> Not applicable  
<li> Total  </ul>

The different education levels are coded as per the Australian Classification of Education (ASCED) 2001. For more information click [here](http://www.abs.gov.au/ausstats/abs@.nsf/Latestproducts/1272.0Main%20Features12001?opendocument&tabname=Summary&prodno=1272.0&issue=2001&num=&view=).  

When using data from the Australian Census it is important to remember that all data is self-reported. This means that care needs to be taken when making conclusions from this data source.  

####Data set 2: Geographic Look Up 
The second data set that we used is a geographic lookup linking SA1s to local government areas (LGAs) and the Greater Capital City Statistical Area (GCCSA) of Greater Melbourne. We compiled this lookup using geographic files for SA1s and LGAs from the ABS and did a spatial join (within QGIS).  [Click here for more information about QGIS](https://www.qgis.org/en/site/).  

The columns in this data set are:  
<ul>
<li> SA1_7DIG16  
<ul><li> 7 digit unique identifier for SA1</ul>
<ul><li> Should be numeric</ul>
<li> LGA_NAME17  
<ul><li> Local council name</ul>
<li> MetroMelbourne  
<ul><li> Indicator of whether the SA1 is within metropolitan Melbourne  </ul>


```{r echo=TRUE, warning=FALSE}
education <- read_excel("allVic_education.xls", skip = 8, col_names = TRUE)
kable(head(education))

geo_lookup <- read_csv("SA1_LGA_LookUp.csv")
kable(head(geo_lookup))

```

After importing the education data set, an error occurred. At the bottom of the dataset, there is a disclaimer with extra informtion. The error states that this information is not imported. This is not an issue as we didn't need that data.


## Understand 

Summarise the types of variables and data structures, check the attributes in the data. In addition to the R codes and outputs, explain briefly the steps that you have taken. In this section, show that you have fulfilled minimum requirements 2-4.

####Data set 1: Education Levels - Types of variables

Character:
<ul>
<li> SA1 7 digit code  </ul>

This variable will need to be converted to a numeric data type so that the data set can be joined with the other data. The SA1 7 digit code is a unique identifier and should not be summed or averaged.

Numeric:
<ul>
<li> Postgraduate Degree Level  
<ul><li> Doctoral Degree Level </ul> 
<ul><li> Masters Degree Level  </ul>
<li> Graduate Diploma and Graduate Certificate Level  
<li> Bachelor Degree Level  
<li> Advanced Diploma and Diploma Level  
<li> Certificate III & IV Level  
<li> Secondary Education Years 10 and above  
<li> Certificate I &II Level  
<li> Secondary Education Years 9 and below  
<li> Supplementary Codes  
<li> Not stated  
<li> Not applicable   
<li> Total  </ul>

The values in these columns are a numeric count of people in each statistical area that have achieved a certain level of education. The levels of education are suitable for creating an ordered factor variable as there is a clear, sensible ordering of each level of education. Before this can be done, the data must be gathered together in a single column. This will be done in the next step. 

####Data set 2: Geographic Look Up - Types of variables 

Integer:
<ul>
<li> SA1_7DIG16  </ul>

Character:
<ul>
<li> LGA_NAME17  
<li> MetroMelbourne  </ul>

The values in this column are categorical data so character is the correct data type. 

Please note that there is one LGA name that is 'Unincorporated Vic'. This is a legitimate value and should not be treated as a missing value.  

```{r echo=TRUE}

#Education Levels

kable(head(education)) #First column and first rows contain no data and need to be trimmed.
kable(tail(education)) #Extra rows at bottom of the data frame with no data, need to be trimmed.
dim(education) #14 columns and 14,081 rows
str(education) #One logical class column with no data. One character column with no header (X__1), will need to be renamed to SA1 and set to numeric so this dataset can be joined to others. The other 12 columns are numeric, containing counts of people with varying levels of educational qualifications in each statistical area.
names(education) #X__1 will need to be changed to SA1. The other headers are varying levels of education qualifications, making this data a good candidate for gathering into a single column as they all pertain to the same type of information.
class(education) #Class of object is a data frame as expected.

#Geographical Data

kable(head(geo_lookup)) #No extra columns or rows to trim.
kable(tail(geo_lookup)) #No extra columns or rows to trim. A few missing values are visible.
dim(geo_lookup) #3 columns and 14,382 rows - more rows than the education data. Will consider this when choosing the type of join to use. 
str(geo_lookup) #First column is SA1 values which are integers. Second column is LGA names which are characters. The third column has Metropolitan Melbourne Areas which are also characters. 
names(geo_lookup) #Names can be more neatly given for the SA1 and LGA variables.
class(geo_lookup) #Class is data frame, as expected.

```


##	Tidy & Manipulate Data I 

Check if the data conforms the tidy data principles. If your data is not in a tidy format, reshape your data into a tidy format (minimum requirement #5). In addition to the R codes and outputs, explain everything that you do in this step.

Firstly, some trimming of extraneous data rows and columns was undertaken to clean the data set and make it more usable for analysis. Similarly, the column name for the education data was changed from the generic X__1 to SA1 to make it easier to understand. A totals row was also added to the data set so that proportions could be calculated for each level of education. 

####Tidy Data Principles:

1. Each variable must have its own column. - population needs to have its own column* Not tidy
2. Each observation must have its own row.
3. Each value must have its own cell.

The data sets do generally conform to the tidy data principles. However, it could be argued that the levels of education in the Education Levels data set qualify as a single variable, rather than a set of different variables. To address this, the gather function has been applied to all the education levels to bring them into a single column called Ed_level. Now the data set is comprised of three attributes, statistical area (SA1), level of education and a count of people in each SA1 that meet a particular level of education.

As mentioned in the previous section, the education level variable is a good candidate for creating an ordered factor variable as there is a naturally ordering of education levels. Education levels were labelled and ordered. Note that some observations had "Not Stated" and "Not Applicable" for education level. These have been ordered last in the factor ordering. 

Now that the Education Levels data is tidy, we have joined it with the Local Government Area lookup data. Now we are able to access how many people in each LGA achieved each particular level of education. In order to do this, SA1 has been converted to a numeric variable in the Education Level data so that it is compatible with the LGA Lookup dataset. A left join was chosen, prioritising the education data on the left hand side as we want to be able to see as many LGAs for each observation in the Education Levels as we can. 

The LGA variable in the LGA Lookup data set is called "LGA_NAME17" which is the metadata label used by the source (ABS). The column name has been changed to LGA which is simpler for users to read. 


```{r echo=TRUE}

#Education Data
education <- education[-1,-1] #Removing first row and column
colnames(education)[1] <- "SA1" #The first column has no header. Setting column header to SA1. 
totalrow <- which(education$SA1 == 'Total') #Add a totals row at the bottom of the data frame. 
education <- education[1:totalrow - 1,] #Removing empty rows at end of data frame.


edu_tidy <- gather(education, "Ed_level", "People", 2:length(education)) #Gathering column variables into a single row

kable(head(edu_tidy))

#Set education level to an ordered factor
edu_tidy <- edu_tidy %>% mutate(Ed_level = factor(Ed_level, levels = c("Postgraduate Degree Level", "Graduate Diploma and Graduate Certificate Level",
                                                                       "Bachelor Degree Level", "Advanced Diploma and Diploma Level", "Certificate III & IV Level",                                          "Secondary Education - Years 10 and above", "Certificate I & II Level", "Secondary Education - Years 9 and below",
                                                                       "Supplementary Codes", "Not stated", "Not applicable", "Total"),
                                                  labels = c("Postgraduate Degree Level", "Graduate Diploma and Graduate Certificate Level",
                                                             "Bachelor Degree Level", "Advanced Diploma and Diploma Level", "Certificate III & IV Level",
                                                             "Secondary Education - Years 10 and above", "Certificate I & II Level", "Secondary Education - Years 9 and below",
                                                             "Supplementary Codes", "Not stated", "Not applicable", "Total"),
                                                  ordered = TRUE))

edu_tidy <- transform(edu_tidy, SA1 = as.numeric(SA1)) #Setting the variable SA1 to numeric so it can be joined with other datasets. 

#Local Government Area Lookup Data - provides a concordance between LGA and SA1 geographic areas
#Left Join Education Data to geographical area lookup to match observations to their LGA.

edu_tidy_join <- edu_tidy %>% left_join(geo_lookup[,c("SA1_7DIG16", "LGA_NAME17", "MetroMelbourne")], by = c("SA1" = "SA1_7DIG16"))

names(edu_tidy_join)[4] <- "LGA" #Change name from LGA_NAME17 to LGA for neatness. 

kable(head(edu_tidy_join))
dim(edu_tidy_join)
str(edu_tidy_join)
kable(tail(edu_tidy_join))

summary(edu_tidy_join)



```

##	Tidy & Manipulate Data II 

Create/mutate at least one variable from the existing variables (minimum requirement #6). In addition to the R codes and outputs, explain everything that you do in this step..

Now that we have Education Levels by LGA from joining the two data sets, we have grouped observations by LGA first, then by Education Level and then calculated a summary of the number of people which each qualification for each LGA.


```{r echo=TRUE}

#Grouping by LGA
edu_by_LGA <- edu_tidy_join %>% group_by(LGA, Ed_level) %>% summarise(PeopleSum = sum(People))

kable(head(edu_by_LGA))
glimpse(edu_by_LGA)


```


##	Scan I 

Scan the data for missing values, inconsistencies and obvious errors. In this step, you should fulfil the minimum requirement #7. In addition to the R codes and outputs, explain how you dealt with these values.

The Education Levels by LGA data has been scanned for missing values (denoted by NA). 12 missing values where identfied in the LGA column using colSums. This makes sense as we have 12 attributes for education level so any counts of people where location data was not available would be recorded as NA. 12 out of 984 records is very small but each record is actually a count of people so if we exclude NAs by using complete.cases, we could end up excluding a large number of people counted. Checking tail(edu_by_LGA), we can see that the total number of counts for people without an LGA identified is 8,119. This compares to the total count of people. 

```{r echo=TRUE}
#Check the Education by LGA data frame for missing values using which(is.na()). 

dim(edu_by_LGA) #There are 984 observations across the 3 variables. 

which(is.na(edu_by_LGA)) #There are a number of missng values at the bottom of the data set. 

colSums(is.na(edu_by_LGA)) #The missing values are in the LGA column, meaning there are some observations of education level that do not have a corresponding LGA available. 

kable(tail(edu_by_LGA))

edu_by_LGA_NAs <- edu_tidy_join %>% group_by(Ed_level) %>% summarise(PeopleSum = sum(People)) #use to demonstrate it's okay to remove NAs

#Remove NAs
edu_by_LGA_complete <- edu_by_LGA[complete.cases(edu_by_LGA), ]

which(is.na(edu_by_LGA_complete)) #Now all missing values have been excluded. 

#Check for the special value
which(is.nan(edu_by_LGA$PeopleSum)) # There are no 'Not a Number' values in the PeopleSum

#Checking for inconsistencies
hist(edu_by_LGA$PeopleSum,
     main = "Population by Local Council Area",
     xlab = "Population",
     ylab = "Count of Councils",
     col = "#66CDAA",
     breaks = 15)


sum_edu <- edu_by_LGA %>% group_by(Ed_level) %>% summarise(PopK = sum(PeopleSum)/1000)
wrapped <- function(strings, width) vapply(strings, function(s)paste(collapse="\n", strwrap(s, width)), FUN.VALUE="", USE.NAMES=FALSE) #May need to reference this code....(http://r.789695.n4.nabble.com/Wrap-names-arg-text-in-barplot-td4593439.html)
barplot(sum_edu$PopK[1:8], names.arg = wrapped(sum_edu$Ed_level[1:8],8),
        las=2, cex.names = 0.8, col = "#9e9ac8",
        main = "Sum of Different Education Levels",
        ylab = "People")


```


##	Scan II

Scan the numeric data for outliers. In this step, you should fulfil the minimum requirement #8. In addition to the R codes and outputs, explain how you dealt with these values.

To scan for outliers, we decided to focus only on postgraduate (including graduate diploma and graduate certificate level) and bachelor degree level observations. The education level data was filtered to contain observations for bachelor degree level and higher as per the ordered factor specified in a previous step. We then refactored the variabiles to only include the three levels of postgraduate degree, graduate diploma/certificate and bachelor degree level. We then plotted a box plot graph to identify if outliers were present and observered a large number of outliers at all three levels of qualification, indicating that the data is heavily positively skewed. 

Next, we mutated the data to create a column for those with a postgraduate qualification (PostGrad, including graduate diploma/certificate) and those with an bachelor degree qualification (undergrad).

One of the issues with scanning for outliers is that each observation is a raw count of people with a certain qualification in each LGA. Therefore, LGAs with larger populations will naturally have higher counts of people for all categories. To account for variances in population size, a proportion has been calcluated of number of people with a postgraduate degree and number of people with a bachelor level degree proportionate to the total number people. Now the box plot is more normally distributed though there are still a number of outliers and the data is still postively skewed. 

Finally, we looked at the combined number of people with either a postgraduate degree or a bachelors degree


```{r echo=TRUE}

# Post grad and Under Grad count
edu_uni <- edu_tidy_join %>% filter(Ed_level <= 'Bachelor Degree Level')
summary(edu_uni)

# Refactor levels of education
edu_uni$Ed_level <- factor(edu_uni$Ed_level,
                           labels = c("Postgraduate Degree Level", "Graduate Diploma and Graduate Certificate Level",
                                      "Bachelor Degree Level"),
                           levels = c("Postgraduate Degree Level", "Graduate Diploma and Graduate Certificate Level",
                                      "Bachelor Degree Level"))
boxplot(edu_uni$People ~ edu_uni$Ed_level, cex.axis = 0.55,
        main = "Distribution of Population within SA1 by Education Level",
        ylab = "Population", xlab = "Education Level")

#let's mutate post and grad into one (total counts)
edu_uni_tot <- education %>%  mutate(Post = (education$`Postgraduate Degree Level` + education$`Graduate Diploma and Graduate Certificate Level`),
                                     UnderGrad = education$`Bachelor Degree Level`) %>% 
                              select(SA1, Post, UnderGrad)
kable(head(edu_uni_tot))
edu_uni_tot$SA1 <- as.numeric(edu_uni_tot$SA1)
edu_uni_tot2 <- edu_uni_tot %>% left_join(geo_lookup[, c('SA1_7DIG16','LGA_NAME17')], by = c('SA1' = 'SA1_7DIG16'))
kable(head(edu_uni_tot2))
glimpse(edu_uni_tot2)

# spread then mutate, will be easier
box_tot <- boxplot(edu_uni_tot2[,2:3], main  = 'Distribution of Population Qualifications',
                        xlab = "Highest Educational Qualification", cex.axis = 0.55,
                        names = c("Postgraduate", "Undergraduate"),
                        ylab = "Population")
length(box_tot$out) # 986 outliers for both postgraduate and undergraduate qualifications

```

```{r}


#let's mutate post and grad into one (but as a proportion of the total)
edu_uni_prop <- education %>%  mutate(Post = (education$`Postgraduate Degree Level` + education$`Graduate Diploma and Graduate Certificate Level`)/education$Total,
                                      UnderGrad = education$`Bachelor Degree Level`/education$Total) %>% 
                                select(SA1, Post, UnderGrad)
kable(head(edu_uni_prop))
glimpse(edu_uni_prop)
edu_uni_prop$SA1 <- as.numeric(edu_uni_prop$SA1)
edu_uni_prop2 <- edu_uni_prop %>% left_join(geo_lookup[, c('SA1_7DIG16','LGA_NAME17')], by = c('SA1' = 'SA1_7DIG16'))
# spread then mutate, will be easier
box_post_prop <- boxplot(edu_uni_prop2[,2], main = 'Proportion of Post Grad Students per Region')
length(box_post_prop$out) # 203 outliers, significant drop in outliers when you take into account the proportion
box_under_prop <- boxplot(edu_uni_prop2[,3], main = 'Proportion of Under Grad Students per Region')
length(box_under_prop$out) # 122 outliers

boxplot(edu_uni_tot2[,2:3])
boxplot(edu_uni_prop2[,2:3]) # both visuals
# finding proportions drastically reduces the count of outliers

### Now what to do with outliers?

####################################
#LGA based outlier work

# Post grad and Under Grad count
edu_uni_lga <- edu_by_LGA %>% filter(Ed_level <= 'Bachelor Degree Level')
summary(edu_uni_lga)
glimpse(edu_uni_lga)

# Refactor levels of education
edu_uni_lga$Ed_level <- factor(edu_uni_lga$Ed_level,
                               labels = c("Postgraduate Degree Level", "Graduate Diploma and Graduate Certificate Level",
                                          "Bachelor Degree Level"),
                               levels = c("Postgraduate Degree Level", "Graduate Diploma and Graduate Certificate Level",
                                          "Bachelor Degree Level"))
boxplot(edu_uni_lga$PeopleSum~edu_uni_lga$Ed_level) 

#let's mutate post and grad into one (total counts)
glimpse(education)
edu_uni_tot_lga <- education %>%  mutate(Post = (education$`Postgraduate Degree Level` + education$`Graduate Diploma and Graduate Certificate Level`),
                                         UnderGrad = education$`Bachelor Degree Level`) %>% select(SA1, Post, UnderGrad)

head(edu_uni_tot)
edu_uni_tot$SA1 <- as.numeric(edu_uni_tot$SA1)
edu_uni_tot2 <- edu_uni_tot %>% left_join(geo_lookup[, c('SA1_7DIG16','LGA_NAME17')], by = c('SA1' = 'SA1_7DIG16'))
head(edu_uni_tot2)
glimpse(edu_uni_tot2)

################################
# Handling Outliers
################################

# Replace NAs with 0 values in the proportions (NA's occured due to 0/0 mutate)
edu_uni_prop2[which(is.na(edu_uni_prop2$Post)),] <- 0
edu_uni_prop2[which(is.na(edu_uni_prop2$UnderGrad)),] <- 0

cap <- function(x){
  quantiles <- quantile( x, c(.05, 0.25, 0.75, .95 ) )
  x[ x < quantiles[2] - 1.5*IQR(x) ] <- quantiles[1]
  x[ x > quantiles[3] + 1.5*IQR(x) ] <- quantiles[4]
  x
} # from Module 6 of MATH 2349, credit to Dr Anil Dolgun

post_cap <- cap(edu_uni_prop2$Post)
boxplot(post_cap, main = 'Post Grad Proportions by LGA Code (Outliers Winsorised)')
summary(post_cap)

under_cap <- cap(edu_uni_prop2$UnderGrad)
boxplot(under_cap, main = 'UnderGrad Proportions by LGA Code (Outliers Winsorised)')
summary(under_cap)

boxplot(post_cap, under_cap)

```



##	Transform 

Apply an appropriate transformation for at least one of the variables. In addition to the R codes and outputs, explain everything that you do in this step. In this step, you should fulfil the minimum requirement #9.

```{r echo=TRUE}

#Filter the data to only include counts of people who completed postgraduate degree level education.

edu_post <- edu_tidy_join %>%  filter(Ed_level == 'Postgraduate Degree Level')

hist(edu_post$People) #Plotting a frequency histogram, the data is heavily right skewed. 

edu_post_log <- log(edu_post$People) #Calculate the natural logarithm of the counts of people

hist(edu_post_log) #The log transformation results a clear normal distribution

#Filter the data to only include counts of people who completed bachelor degree level education.

edu_under <- edu_tidy_join %>%  filter(Ed_level == 'Bachelor Degree Level')

hist(edu_under$People) #Plotting a frequency histogram, the data is also heavily right skewed. 

edu_under_log <- log(edu_under$People) #Applied the same treatment as above, taking the natural logarithm of the count. 

hist(edu_under_log) #Again, the data is now normally distributed as a result of the log transformation. 


```


##  Additional Step: Machine Learning
```{r echo=TRUE}
# If we know how many undergrad students we have, can you predict how many students will undertake post grad courses?
# Select data for ml
data <- edu_uni_tot2[2:3]

# Make task
task <- makeRegrTask(data = data, target = 'Post')

# Make learner
learner <- makeLearner('regr.glm')

# Fit model
n <- nrow(data)
training.set <- sample(n, size = 2*n/3)
test.set <- setdiff(1:n, training.set)

model <- mlr::train(learner, task, subset = training.set)

# Predict
pred <- predict(model, task = task, subset = test.set)

# Evaluate
performance(pred, measures = list(mse, mae))

x <- pred$data$truth
y <- pred$data$response
plot(x, y, xlab = 'Actual Value', ylab = 'Predicted Value', col = 'blue', main = 'Regression Machine Learning')
abline(1:500, 1:500, lwd = 2, col = 'red')
```

NOTE: Follow the order outlined above in the report. Make sure your code is visible (within the margin of the page). Do not use View() to show your data instead give headers (using head() )


Any further or optional pre-processing tasks can be added to the template using an additional section in the R Markdown file. Please also provide the R codes, outputs and brief explanations on why and how you applied these tasks on the data.

<br>
<br>
